# Script to create plots for knowing insights from the data generated by training the model
import ast
import os
import re

import matplotlib.cm as cm
import matplotlib.lines as mlines
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import torch


def save_results_to_csv(
    **kwargs,
):
    file_name = kwargs.get("file_name")
    kwargs.pop("file_name")
    data = {key: [value] for key, value in kwargs.items()}

    # Convert the dictionary to a pandas DataFrame
    df = pd.DataFrame(data)

    # If the file exists, load the existing data and append the new data
    if os.path.isfile(file_name):
        df_existing = pd.read_csv(file_name)
        df = pd.concat([df_existing, df], ignore_index=True)

    df.to_csv(file_name, index=False)


def extract_tensors_from_string(s):
    numbers = re.findall(r"tensor\((.*?)\)", s)
    return [torch.tensor(float(number)) for number in numbers]


def plot_iterations_train_times_vs_epoch(
    data,
    labels,
    save_dir,
):
    results = data
    # Create a color map
    unique_keys = results["algorithm"] + " " + results["noise_multiplier"].astype(str)
    if "k_fold_iteration" in results:
        unique_keys += (
            " "
            + "F:"
            + results["k_fold_iteration"].astype(str)
            + "/"
            + results["k_fold"].astype(str)
        )
    unique_keys = unique_keys.unique()
    colors = cm.rainbow(np.linspace(0, 1, len(unique_keys)))
    color_map = dict(zip(unique_keys, colors))

    plt.figure(1)
    for label in labels:
        data_subset = data[data["algorithm"] == label]
        for index, row in data_subset.iterrows():
            """
            if str(row["noise_multiplier"]) in ["0.3", "0.6"]:
                continue
            """
            epochs = list(range(1, len(row["iteration_train_times"]) + 1))
            if row["algorithm"] in ["bk", "opacus"]:
                label = row["algorithm"] + " " + str(row["noise_multiplier"])
                if "k_fold_iteration" in row:
                    label += (
                        " "
                        + "F:"
                        + str(row["k_fold_iteration"])
                        + "/"
                        + str(row["k_fold"])
                    )
                color = color_map[label]
                plt.plot(epochs, row["iteration_train_times"], color=color, label=label)
            else:
                label = row["algorithm"] + " " + str(row["epochs"])
                if "k_fold_iteration" in row:
                    label += (
                        " "
                        + "F:"
                        + str(row["k_fold_iteration"])
                        + "/"
                        + str(row["k_fold"])
                    )
                plt.plot(epochs, row["iteration_train_times"], label=label)

    plt.xlabel("Epoch")
    plt.ylabel("Time (s)")
    plt.yscale("log")
    plt.title("Iterations Train times Vs Epoch")
    plt.legend()
    plt.savefig(os.path.join(save_dir, "Iterations_Train_times_Vs_Epoch.png"))
    plt.close()


def plot_training_loss_vs_epoch(data, labels, save_dir):
    results = data

    # Create a color map
    unique_keys = results["algorithm"] + " " + results["noise_multiplier"].astype(str)
    if "k_fold_iteration" in results:
        unique_keys += (
            " "
            + "F:"
            + results["k_fold_iteration"].astype(str)
            + "/"
            + results["k_fold"].astype(str)
        )
    unique_keys = unique_keys.unique()
    colors = cm.rainbow(np.linspace(0, 1, len(unique_keys)))
    color_map = dict(zip(unique_keys, colors))

    plt.figure(2)

    for label in labels:
        data_subset = data[data["algorithm"] == label]
        for index, row in data_subset.iterrows():
            """
            if str(row["noise_multiplier"]) in ["0.6", "1.0"]:
                continue
            """
            epochs = list(range(1, len(row["training_losses"]) + 1))
            if row["algorithm"] in ["bk", "opacus"]:
                label = row["algorithm"] + " " + str(row["noise_multiplier"])
                if "k_fold_iteration" in row:
                    label += (
                        " "
                        + "F:"
                        + str(row["k_fold_iteration"])
                        + "/"
                        + str(row["k_fold"])
                    )
                color = color_map[label]
                plt.plot(epochs, row["training_losses"], color=color, label=label)
            else:
                label = row["algorithm"] + " " + str(row["epochs"])
                if "k_fold_iteration" in row:
                    label += (
                        " "
                        + "F:"
                        + str(row["k_fold_iteration"])
                        + "/"
                        + str(row["k_fold"])
                    )
                plt.plot(epochs, row["training_losses"], label=label)

    plt.xlabel("Epoch")
    plt.ylabel("Training Loss")
    plt.title("Training Loss Vs Epoch")
    plt.legend()
    plt.savefig(os.path.join(save_dir, "Training_Loss_Vs_Epoch.png"))
    plt.close()


def plot_validation_loss_vs_epoch(data, labels, save_dir):
    results = data
    # Create a color map
    unique_keys = results["algorithm"] + " " + results["noise_multiplier"].astype(str)
    if "k_fold_iteration" in results:
        unique_keys += (
            " "
            + "F:"
            + results["k_fold_iteration"].astype(str)
            + "/"
            + results["k_fold"].astype(str)
        )
    unique_keys = unique_keys.unique()
    colors = cm.rainbow(np.linspace(0, 1, len(unique_keys)))
    color_map = dict(zip(unique_keys, colors))

    plt.figure(3)
    for label in labels:
        data_subset = results[results["algorithm"] == label]
        for index, row in data_subset.iterrows():
            """
            if str(row["noise_multiplier"]) in ["0.3", "0.6"]:
                continue
            """
            if row["algorithm"] in ["bk", "opacus"]:
                label = row["algorithm"] + " " + str(row["noise_multiplier"])
                if "k_fold_iteration" in row:
                    label += (
                        " "
                        + "F:"
                        + str(row["k_fold_iteration"])
                        + "/"
                        + str(row["k_fold"])
                    )
                color = color_map[label]
                epochs = list(range(1, len(row["validation_losses"]) + 1))
                plt.plot(epochs, row["validation_losses"], color=color, label=label)
            else:
                label = row["algorithm"] + " " + str(row["epochs"])
                if "k_fold_iteration" in row:
                    label += (
                        " "
                        + "F:"
                        + str(row["k_fold_iteration"])
                        + "/"
                        + str(row["k_fold"])
                    )
                epochs = list(range(1, len(row["validation_losses"]) + 1))
                plt.plot(epochs, row["validation_losses"], label=label)

    plt.xlabel("Epoch")
    plt.ylabel("Validation Loss")
    plt.title("Validation Loss Vs Epoch")
    plt.legend()
    plt.savefig(os.path.join(save_dir, "Validation_Loss_Vs_Epoch.png"))
    plt.close()


def plot_iterations_train_times_vs_epoch_with_different_noise_multiplier(
    data,
    labels,
    save_dir,
):
    results = data
    # Create a color map
    unique_keys = results["algorithm"] + " " + results["noise_multiplier"].astype(str)
    if "k_fold_iteration" in results:
        unique_keys += (
            " "
            + "F:"
            + results["k_fold_iteration"].astype(str)
            + "/"
            + results["k_fold"].astype(str)
        )
    unique_keys = unique_keys.unique()
    colors = cm.rainbow(np.linspace(0, 1, len(unique_keys)))
    color_map = dict(zip(unique_keys, colors))

    plt.figure(4)
    lines = []  # for storing legend lines
    for index, row in results.iterrows():
        """
        if str(row["noise_multiplier"]) in ["0.3", "1.0"]:
            continue
        """
        if row["algorithm"] not in ["bk", "opacus"]:
            continue
        key = row["algorithm"] + " " + str(row["noise_multiplier"])
        if "k_fold_iteration" in row:
            key += " " + "F:" + str(row["k_fold_iteration"]) + "/" + str(row["k_fold"])
        color = color_map[key]
        epochs = list(range(1, row["epochs"] + 1))
        plt.plot(epochs, row["iteration_train_times"], color=color, label=key)
        lines.append(
            mlines.Line2D([], [], color=color, label=key)
        )  # create a line for this label

    plt.xlabel("Epoch")
    plt.ylabel("Time (s)")
    plt.yscale("log")
    plt.title("Iterations Train times Vs Epoch")
    plt.legend(handles=lines)
    plt.savefig(
        os.path.join(save_dir, "Iterations_Train_times_Vs_Epoch_Different_NM.png")
    )
    plt.close()


def plot_epsilon_vs_epoch(data, labels, save_dir):
    # Convert overall_privacy_spent from string to list of dicts for bk
    results = data
    bk_results = results[results["algorithm"] == "bk"]
    bk_results["overall_privacy_spent"] = bk_results["overall_privacy_spent"].apply(
        ast.literal_eval
    )
    bk_results["eps"] = bk_results["overall_privacy_spent"].apply(
        lambda x: [item["eps_rdp"] for item in x]
    )

    # Convert eps from string to list for opacus
    opacus_results = results[results["algorithm"] == "opacus"]
    opacus_results["eps"] = opacus_results["overall_privacy_spent"].apply(
        ast.literal_eval
    )

    # Create a color map
    unique_keys = results["algorithm"] + " " + results["noise_multiplier"].astype(str)
    if "k_fold_iteration" in results:
        unique_keys += (
            " "
            + "F:"
            + results["k_fold_iteration"].astype(str)
            + "/"
            + results["k_fold"].astype(str)
        )
    unique_keys = unique_keys.unique()
    colors = cm.rainbow(np.linspace(0, 1, len(unique_keys)))
    color_map = dict(zip(unique_keys, colors))

    # Plot Epsilon vs Epoch for bk and opacus
    plt.figure(5)
    lines = []  # for storing legend lines
    for label in labels:
        if label == "bk":
            data_subset = bk_results
        elif label == "opacus":
            data_subset = opacus_results
        else:
            continue
        for index, row in data_subset.iterrows():
            """
            if str(row["noise_multiplier"]) in ["0.6", "0.3"]:
                continue
            """
            if "k_fold_iteration" in row:
                label = (
                    str(row["algorithm"])
                    + " "
                    + str(row["noise_multiplier"])
                    + " "
                    + "F:"
                    + str(row["k_fold_iteration"])
                    + "/"
                    + str(row["k_fold"])
                )
            color = color_map[label]
            epochs = list(range(1, len(row["eps"]) + 1))
            plt.plot(
                epochs,
                row["eps"],
                color=color,
                label=label,
            )
            lines.append(
                mlines.Line2D(
                    [],
                    [],
                    color=color,
                    label=label,
                )
            )  # create a line for this label

    plt.xlabel("Epoch")
    plt.ylabel("Epsilon")
    plt.title("Epsilon Vs Epoch")
    plt.legend(handles=lines)
    plt.savefig(os.path.join(save_dir, "Epsilon_Vs_Epoch.png"))
    plt.close()


def plot_noise_multiplier_vs_overall_privacy_spent(
    data,
    labels,
    save_dir,
):
    results = data
    bk_results = results[results["algorithm"] == "bk"]
    bk_results["overall_privacy_spent"] = bk_results["overall_privacy_spent"].apply(
        ast.literal_eval
    )
    bk_results["eps"] = bk_results["overall_privacy_spent"].apply(
        lambda x: [item["eps_rdp"] for item in x]
    )

    # Convert eps from string to list for opacus
    opacus_results = results[results["algorithm"] == "opacus"]
    opacus_results["eps"] = opacus_results["overall_privacy_spent"].apply(
        ast.literal_eval
    )
    # Create a color map
    unique_keys = results["algorithm"] + " " + results["noise_multiplier"].astype(str)
    if "k_fold_iteration" in results:
        unique_keys += (
            " "
            + "F:"
            + results["k_fold_iteration"].astype(str)
            + "/"
            + results["k_fold"].astype(str)
        )
    unique_keys = unique_keys.unique()
    colors = cm.rainbow(np.linspace(0, 1, len(unique_keys)))
    color_map = dict(zip(unique_keys, colors))

    plt.figure(6)
    lines = []  # for storing legend lines
    labels = ["bk", "opacus"]

    for label in labels:
        if label == "bk":
            data_subset = bk_results
        else:
            data_subset = opacus_results
        for noise_multiplier in data_subset["noise_multiplier"].unique():
            noise_multiplier_subset = data_subset[
                data_subset["noise_multiplier"] == noise_multiplier
            ]
            for index, row in noise_multiplier_subset.iterrows():
                # if str(row["noise_multiplier"]) in ["1.0", "0.6"]:
                #    continue
                label = str(row["algorithm"]) + " " + str(row["noise_multiplier"])
                if "k_fold_iteration" in row:
                    label += (
                        " "
                        + "F:"
                        + str(row["k_fold_iteration"])
                        + "/"
                        + str(row["k_fold"])
                    )
                color = color_map[label]
                epochs = list(range(1, len(row["iteration_train_times"]) + 1))
                plt.plot(
                    epochs,
                    row["eps"],
                    color=color,
                    label=label,
                )
                lines.append(
                    mlines.Line2D(
                        [],
                        [],
                        color=color,
                        label=label,
                    )
                )

    plt.xlabel("Epoch")
    plt.ylabel("Overall Privacy Spent (eps_rdp)")
    plt.title("Overall Privacy Spent vs Epoch for different Noise Multipliers")
    plt.legend(handles=lines)
    plt.savefig(os.path.join(save_dir, "Noise_Multiplier_Vs_Overall_Privacy_Spent.png"))
    plt.close()


def plot_noise_multiplier_vs_mean_training_losses(
    data,
    labels,
    save_dir,
):
    results = data
    bk_results = results[results["algorithm"] == "bk"]
    bk_results["overall_privacy_spent"] = bk_results["overall_privacy_spent"].apply(
        ast.literal_eval
    )
    bk_results["eps"] = bk_results["overall_privacy_spent"].apply(
        lambda x: [item["eps_rdp"] for item in x]
    )
    opacus_results = results[results["algorithm"] == "opacus"]
    opacus_results["eps"] = opacus_results["overall_privacy_spent"].apply(
        ast.literal_eval
    )
    # Create a color map
    unique_keys = results["algorithm"] + " " + results["noise_multiplier"].astype(str)
    if "k_fold_iteration" in results:
        unique_keys += (
            " "
            + "F:"
            + results["k_fold_iteration"].astype(str)
            + "/"
            + results["k_fold"].astype(str)
        )
    unique_keys = unique_keys.unique()
    colors = cm.rainbow(np.linspace(0, 1, len(unique_keys)))
    color_map = dict(zip(unique_keys, colors))

    plt.figure(7)
    lines = []  # for storing legend lines
    labels = ["bk", "opacus"]

    for label in labels:
        if label == "bk":
            data_subset = bk_results
        else:
            data_subset = opacus_results
        for noise_multiplier in data_subset["noise_multiplier"].unique():
            noise_multiplier_subset = data_subset[
                data_subset["noise_multiplier"] == noise_multiplier
            ]
            for index, row in noise_multiplier_subset.iterrows():
                if str(row["noise_multiplier"]) in ["1.0", "0.3"]:
                    continue
                label = str(row["algorithm"]) + " " + str(row["noise_multiplier"])
                if "k_fold_iteration" in row:
                    label += (
                        " "
                        + "F:"
                        + str(row["k_fold_iteration"])
                        + "/"
                        + str(row["k_fold"])
                    )
                color = color_map[label]
                epochs = list(range(1, len(row["training_losses"]) + 1))
                plt.plot(
                    epochs,
                    row["training_losses"],
                    color=color,
                    label=label,
                )
                lines.append(
                    mlines.Line2D(
                        [],
                        [],
                        color=color,
                        label=label,
                    )
                )
    plt.xlabel("Epoch")
    plt.ylabel("Mean Training Losses")
    plt.title("Mean Training Losses vs Epoch for different Noise Multipliers")
    plt.legend()
    plt.savefig(os.path.join(save_dir, "Noise_Multiplier_Vs_Mean_Training_Losses.png"))
    plt.close()


def plot_mean_validation_loss_per_epoch(data, labels, save_dir):
    results = data
    results["mean_validation_loss"] = results["validation_losses"].apply(
        lambda x: np.mean(x)
    )
    grouped = (
        data.groupby(["noise_multiplier", "algorithm"])["mean_validation_loss"]
        .mean()
        .reset_index()
    )
    plt.figure(8)
    for label in labels:
        subset = grouped[grouped["algorithm"] == label]
        if subset.empty:
            continue
        plt.bar(
            subset["noise_multiplier"].astype(str) + "\n" + " (" + label[0] + ")",
            subset["mean_validation_loss"],
            label=label,
        )

    plt.xlabel("Noise Multiplier")
    plt.ylabel("Mean Validation Loss")
    plt.title("Mean Validation Loss Per Epoch for Different Noise Multipliers")
    plt.legend()
    plt.savefig(os.path.join(save_dir, "Mean_Validation_Loss_Per_Epoch.png"))
    plt.close()


def plot_metrics_from_csv():
    file_names = [
        "results-k-fold/bk/3/unet_Duke.csv",
        "results-k-fold/Non_DP/3/unet_Duke.csv",
        "results-k-fold/opacus/3/unet_Duke.csv",
    ]
    # Overall:
    # Plot Iterations Train times Vs Epoch for DP(bk, opacus) and Non-DP
    # Plot Training Loss Vs Epoch for DP (bk, opacus) and Non-DP
    # Plot Validation Loss Vs Epoch for DP (bk, opacus) and Non-DP

    # Fast DP and Opacus results
    # Plot iterations train times vs noise multiplier for bk and opacus
    # Plot Epsilon vs Epoch for bk and opacus
    # Plot noise multiplier vs overall privacy spent (alpha_rdp and eps_rdp)
    # Plot noise multiplier vs mean training losses

    colors = ["r", "g", "b"]
    labels = ["bk", "Non_DP", "opacus"]
    dataframes = []

    for file_name, color, label in zip(file_names, colors, labels):
        if not os.path.exists(file_name):
            print(f"File {file_name} does not exist.")
            continue
        data = pd.read_csv(file_name)
        data["label"] = label
        dataframes.append(data)
    results = pd.concat(dataframes, ignore_index=True)
    results["iteration_train_times"] = results["iteration_train_times"].apply(
        ast.literal_eval
    )
    results["training_losses"] = results["training_losses"].apply(ast.literal_eval)
    results["validation_losses"] = results["validation_losses"].apply(ast.literal_eval)

    save_dir = "results-k-fold/csv_insights"
    os.makedirs(save_dir, exist_ok=True)

    # plot_iterations_train_times_vs_epoch(results, labels, save_dir)
    # plot_training_loss_vs_epoch(results, labels, save_dir)
    # plot_validation_loss_vs_epoch(results, labels, save_dir)
    # plot_iterations_train_times_vs_epoch_with_different_noise_multiplier(
    #    results, labels, save_dir
    # )
    # plot_epsilon_vs_epoch(results, labels, save_dir)
    # plot_noise_multiplier_vs_overall_privacy_spent(results, labels, save_dir)
    # plot_noise_multiplier_vs_mean_training_losses(results, labels, save_dir)
    plot_mean_validation_loss_per_epoch(results, labels, save_dir)


if __name__ == "__main__":
    plot_metrics_from_csv()
